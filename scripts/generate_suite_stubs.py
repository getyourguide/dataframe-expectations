#!/usr/bin/env python3
"""
Script to generate .pyi stub file for DataFrameExpectationsSuite.

This script reads the expectation metadata from the registry and generates
a .pyi stub file that provides IDE autocomplete for all expect_* methods.

Usage:
    python scripts/generate_suite_stubs.py          # Generate expectations_suite.pyi
    python scripts/generate_suite_stubs.py --check  # Only check if stub file is up-to-date
    python scripts/generate_suite_stubs.py --print  # Print generated stubs to stdout
"""

import argparse
import sys
from pathlib import Path
from typing import Any, Dict

# Add project root to path for imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


def format_type_hint(type_hint: Any) -> str:
    """
    Format a type hint for use in function signatures.

    Args:
        type_hint: The type or tuple of types to format

    Returns:
        A string representation of the type hint
    """
    if type_hint is None:
        return "object"

    # Handle tuple of types (e.g., (int, float) -> Union[int, float])
    if isinstance(type_hint, tuple):
        type_names = []
        for t in type_hint:
            if hasattr(t, '__name__'):
                type_names.append(t.__name__)
            else:
                type_names.append(str(t))

        if len(type_names) == 1:
            return type_names[0]
        return f"Union[{', '.join(type_names)}]"

    # Handle single type
    if hasattr(type_hint, '__name__'):
        return type_hint.__name__

    return str(type_hint)


def generate_stub_method(
    suite_method_name: str,
    expectation_name: str,
    metadata: Dict[str, Any]
) -> str:
    """
    Generate a stub method for a single expectation.

    Args:
        suite_method_name: The name of the suite method (e.g., 'expect_value_equals')
        expectation_name: The name of the expectation class (e.g., 'ExpectationValueEquals')
        metadata: The metadata dictionary for the expectation

    Returns:
        The generated method code as a string
    """
    description = metadata.get('description', '')
    category = metadata.get('category', '')
    subcategory = metadata.get('subcategory', '')
    params = metadata.get('params', [])
    params_doc = metadata.get('params_doc', {})
    param_types = metadata.get('param_types', {})

    # Build parameter list with type hints
    param_list = []
    for param in params:
        param_type = param_types.get(param, object)
        type_str = format_type_hint(param_type)
        param_list.append(f"{param}: {type_str}")

    params_signature = ",\n        ".join(param_list)

    # Build docstring
    docstring_lines = [
        '        """',
        f'        {description}',
        '',
        '        Categories:',
        f'          category: {category}',
        f'          subcategory: {subcategory}',
        ''
    ]

    for param in params:
        param_doc = params_doc.get(param, '')
        docstring_lines.append(f'        :param {param}: {param_doc}')

    docstring_lines.append('        :return: an instance of DataFrameExpectationsSuite.')
    docstring_lines.append('        """')

    # Generate the method signature for .pyi file (no implementation)
    method_code = f'''    def {suite_method_name}(
        self,
        {params_signature},
    ) -> DataFrameExpectationsSuite:
{chr(10).join(docstring_lines)}
        ...
'''

    return method_code


def generate_pyi_file() -> str:
    """
    Generate complete .pyi stub file content.

    Returns:
        The complete .pyi file content as a string
    """
    # Import here to avoid issues if not in the right directory
    from dataframe_expectations.expectations.expectation_registry import (
        DataFrameExpectationRegistry,
    )

    # Get all metadata and suite method mapping
    mapping = DataFrameExpectationRegistry.get_suite_method_mapping()

    # Start with imports and class definition
    pyi_content = [
        '# Type stubs for DataFrameExpectationsSuite',
        '# Auto-generated by scripts/generate_suite_stubs.py',
        '# DO NOT EDIT - Regenerate with: python scripts/generate_suite_stubs.py',
        '',
        'from typing import List, Union',
        'from dataframe_expectations.expectations import DataFrameLike',
        'from dataframe_expectations.result_message import DataFrameExpectationFailureMessage',
        '',
        'class DataFrameExpectationsSuiteFailure(Exception):',
        '    failures: List[DataFrameExpectationFailureMessage]',
        '    total_expectations: int',
        '    def __init__(',
        '        self,',
        '        total_expectations: int,',
        '        failures: List[DataFrameExpectationFailureMessage],',
        '        *args,',
        '    ) -> None: ...',
        '',
        'class DataFrameExpectationsSuite:',
        '    def __init__(self) -> None: ...',
        '',
    ]

    # Generate all stub methods (sorted for consistency)
    for suite_method, exp_name in sorted(mapping.items()):
        metadata = DataFrameExpectationRegistry.get_metadata(exp_name)
        pyi_content.append(generate_stub_method(suite_method, exp_name, metadata))

    # Add run method
    pyi_content.extend([
        '    def run(self, data_frame: DataFrameLike) -> None: ...',
        ''
    ])

    return '\n'.join(pyi_content)


def update_pyi_file(dry_run: bool = False) -> bool:
    """
    Update the expectations_suite.pyi stub file.

    Args:
        dry_run: If True, only check if update is needed without writing

    Returns:
        True if file was updated (or would be updated in dry_run mode), False otherwise
    """
    pyi_file = Path(__file__).parent.parent / 'dataframe_expectations' / 'expectations_suite.pyi'

    # Generate the new .pyi content
    new_content = generate_pyi_file()

    # Check if file exists and compare
    old_content = ''
    if pyi_file.exists():
        with open(pyi_file, 'r') as f:
            old_content = f.read()

    if new_content == old_content:
        print("✅ Stub file is up-to-date")
        return False

    if dry_run:
        print("❌ Stub file is out of date. Run without --check to update.")
        return True

    # Write the .pyi file
    with open(pyi_file, 'w') as f:
        f.write(new_content)

    # Count the methods
    from dataframe_expectations.expectations.expectation_registry import (
        DataFrameExpectationRegistry,
    )
    method_count = len(DataFrameExpectationRegistry.get_suite_method_mapping())

    print(f"✅ Successfully generated {method_count} stub methods in {pyi_file}")
    return True


def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description='Generate .pyi stub file for DataFrameExpectationsSuite',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate expectations_suite.pyi
  python scripts/generate_suite_stubs.py

  # Check if stub file is up-to-date (useful for CI)
  python scripts/generate_suite_stubs.py --check

  # Print generated stubs to stdout
  python scripts/generate_suite_stubs.py --print
        """
    )

    parser.add_argument(
        '--check',
        action='store_true',
        help='Check if stub file is up-to-date without modifying files'
    )

    parser.add_argument(
        '--print',
        action='store_true',
        help='Print generated stub file to stdout instead of writing'
    )

    args = parser.parse_args()

    try:
        if args.print:
            # Just print the generated stub file
            pyi_content = generate_pyi_file()
            print(pyi_content)
            return 0
        else:
            # Update the .pyi file (or check if it needs updating)
            needs_update = update_pyi_file(dry_run=args.check)

            if args.check and needs_update:
                return 1  # Exit with error code for CI

            return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
